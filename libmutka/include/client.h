#ifndef LIBMUTKA_CLIENT_H
#define LIBMUTKA_CLIENT_H

#include <pthread.h>
#include <sys/socket.h>

#include "packet.h"
#include "env.h"
#include "cryptography.h"




#define MUTKA_NICKNAME_MAX 24
#define MUTKA_PATH_MAX 256
#define MUTKA_HOST_ADDR_MAX 16
// mutka_client_cfg flags
#define MUTKA_CCFG_HAS_TRUSTED_PUBLKEY (1 << 0)
#define MUTKA_CCFG_HAS_TRUSTED_PRIVKEY (1 << 1)


struct mutka_client;

struct mutka_client_cfg {
    char  nickname[MUTKA_NICKNAME_MAX];

    bool  use_default_cfgdir;
    char  mutka_cfgdir[MUTKA_PATH_MAX]; // Modified by 'mutka_validate_client_cfg()'
                                            // If 'use_default_cfgdir' is set to 'true'
    
    // Config paths are set by mutka_validate_client_cfg()
    char  trusted_peers_dir[MUTKA_PATH_MAX];
    char  trusted_privkey_path[MUTKA_PATH_MAX];
    char  trusted_publkey_path[MUTKA_PATH_MAX];
    char  trusted_hosts_path[MUTKA_PATH_MAX];

    char  trusted_privkey[ED25519_KEYLEN]; // From mutka_decrypt_trusted_privkey()
    char  trusted_publkey[ED25519_KEYLEN]; // From mutka_read_trusted_publkey()


    // When client connects to server for the first time
    // or doesnt have the server host ed25519 public key in trusted_hosts file.
    // This callback can return 'true' if it allows it to be added, 
    // If 'false' is returned client is going to be disconnected.
    bool(*add_new_trusted_host_callback)(struct mutka_client*, struct mutka_str* /*host public key*/);

    int flags;
};



struct mutka_client {
    pthread_mutex_t      mutex;

    enum mutka_env       env;
    int                  socket_fd;
    struct sockaddr_in   socket_addr;
    struct mutka_str     peer_metadata_publkey;

    int                  uid; // Random unique ID. (Generated by the server)


    // ======( Not available on server side )======
   
    char host_addr[MUTKA_HOST_ADDR_MAX];
    uint32_t host_addr_len;

    struct mutka_keypair metadata_keys;
     
    struct mutka_raw_packet out_raw_packet;
    struct mutka_packet     inpacket; // Last received parsed packet.
    
    void(*packet_received_callback)(struct mutka_client*);
    
    /*TODO REMOVE THIS*/bool handshake_complete;

    struct mutka_client_cfg config;
};


bool mutka_validate_client_cfg(struct mutka_client_cfg* config, char* nickname);
bool mutka_cfg_trustedkeys_exists(struct mutka_client_cfg* config);

// Passphase is required for encrypting the trusted private key file.
bool mutka_cfg_generate_trustedkeys
(
    struct mutka_client_cfg* config,
    char* privkey_passphase, size_t passphase_len
);

bool mutka_decrypt_trusted_privkey
(
    struct mutka_client_cfg* config,
    char* passphase, size_t passphase_len
);


// Trusted public key is not encrypted.
bool mutka_read_trusted_publkey(struct mutka_client_cfg* config);

struct mutka_client* mutka_connect(struct mutka_client_cfg* config, char* host, uint16_t port);

void mutka_init_metadata_key_exchange(struct mutka_client* client);

// This function behaves little bit differently depending on the
// Environment which the function was called from MUTKA_ENV_SERVER or MUTKA_ENV_CLIENT
void mutka_disconnect(struct mutka_client* client);



#endif
